{"meta":{"title":"Shane","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2020-05-05T02:25:58.959Z","updated":"2020-05-05T02:21:49.831Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2020-05-05T04:42:54.207Z","updated":"2020-05-05T04:42:54.207Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis学习系列（二）事务和配置文件","slug":"Redis学习系列（二）事务和配置文件","date":"2020-06-20T15:08:12.000Z","updated":"2020-06-20T15:09:28.724Z","comments":true,"path":"2020/06/20/Redis学习系列（二）事务和配置文件/","link":"","permalink":"http://yoursite.com/2020/06/20/Redis%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"Redis（二）三种特殊的数据类型、事务、redis.conf三种特殊的数据类型1、geospatialredis地理位置。定位，距离计算。 Redis的Geo能够推算地理位置信息，两地之间的距离，一定半径内的人。 一共有六个命令 geoadd 123456789101112#规则：两级无法直接添加，可以直接通过java程序一次性导入#参数：key 值（纬度，经度，名称）127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing(integer) 1127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai(integer) 1127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqin(integer) 1127.0.0.1:6379&gt; geoadd china:city 114.05 22.52 shengzhen(integer) 1127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou(integer) 1 geopos 12345#获得位置127.0.0.1:6379&gt; geopos china:city hangzhou1) 1) \"120.1600000262260437\" 2) \"30.2400003229490224\"127.0.0.1:6379&gt; geodist 123#直线距离127.0.0.1:6379&gt; geodist china:city hangzhou beijing km\"1127.3378\" georadius 以给定的经纬度为中心，找出某一半径内的元素 123127.0.0.1:6379&gt; georadius china:city 120 30 1000 km1) \"hangzhou\"2) \"shanghai\" georadiusbymember 以给定的成员找某一半径内的元素 geohash 该命令返回一个11字符长度的字符串 是基于Zset的，所以Zset的命令可以直接使用。 Hyperloglog基数：不重复的元素，可以接受误差 Hyperloglog用于做基数统计。 1234567891011121314127.0.0.1:6379&gt; pfadd mykey 1 2 3 4 5 6 i j k(integer) 1127.0.0.1:6379&gt; pfcount mykey (integer) 9127.0.0.1:6379&gt; pfadd mykey i j k a d b (integer) 1127.0.0.1:6379&gt; pfcount mykey (integer) 12127.0.0.1:6379&gt; pfadd mykey2 i j a f f e e(integer) 1127.0.0.1:6379&gt; pfmerge mykey3 mykey mykey2OK127.0.0.1:6379&gt; pfcount mykey3(integer) 14 如果允许容错，可以使用 不允许容错，就不可以使用 Bitmaps按位存储 位图。 操作二进制来进行记录。只有0和1的状态 12345678910111213141516171819202122232425#周一1；周二0；。。。127.0.0.1:6379&gt; setbit sign 0 1(integer) 0127.0.0.1:6379&gt; setbit sign 1 0(integer) 0127.0.0.1:6379&gt; setbit sign 2 0(integer) 0127.0.0.1:6379&gt; setbit sign 3 3(error) ERR bit is not an integer or out of range127.0.0.1:6379&gt; setbit sign 3 1(integer) 0127.0.0.1:6379&gt; setbit sign 4 1(integer) 0127.0.0.1:6379&gt; setbit sign 5 1(integer) 0127.0.0.1:6379&gt; setbit sign 6 0(integer) 0#查看127.0.0.1:6379&gt; getbit sign 1(integer) 0#统计打卡天数127.0.0.1:6379&gt; bitcount sign(integer) 4 事务Redis单条命令能够保证原子性，事务不保证原子性 Redis没有隔离级别的概念 所有的命令在事务中，并没有直接被执行。只有发起执行命令的时候才会执行 redis的事务： 开启事务multi 命令入队 执行事务exec 123456789101112127.0.0.1:6379&gt; multi#开启事务OK127.0.0.1:6379&gt; set k1 k1#命令入队QUEUED127.0.0.1:6379&gt; set k2 k2#命令入队QUEUED127.0.0.1:6379&gt; get k2#命令入队QUEUED127.0.0.1:6379&gt; exec#执行事务1) OK2) OK3) \"k2\" 放弃事务 123456789101112127.0.0.1:6379&gt; multi#开启事务OK127.0.0.1:6379&gt; set k1 v1#命令入队QUEUED127.0.0.1:6379&gt; set k2 v2#命令入队QUEUED127.0.0.1:6379&gt; set k4 v4#命令入队QUEUED127.0.0.1:6379&gt; discard#放弃事务OK127.0.0.1:6379&gt; get key4#查看之间的命令是否执行，发现队列中的命令都没有执行(nil) 编译型异常（代码有问题！命令有错！），事务中的所有命令都不会被执行！ 运行时异常(例如除零异常），如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令会抛出异常！ 12345678910111213127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1 QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; getset k3#编译型异常(error) ERR wrong number of arguments for 'getset' command127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; exec(error) EXECABORT Transaction discarded because of previous errors.#所有的命令都没有执行 123456789101112131415127.0.0.1:6379&gt; set k1 \"v1\"OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr k1#运行时异常QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; exec1) (error) ERR value is not an integer or out of range2) OK3) \"v2\"#虽然第一条命令报错，但是其他命令没有受到影响。 监控 悲观锁：无论做什么都会加锁 乐观锁：认为任何时候都不会处问题，所以不会上锁，更新数据的时候可以判断一下，在此期间是否有人修改过这个数据 获取version 更新的时候比较version 1234567891011121314151617127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; decrby money 20QUEUED127.0.0.1:6379&gt; incrby out 20QUEUED127.0.0.1:6379&gt; exec1) (integer) 802) (integer) 20 多线程修改值，使用watch可以当作redis的乐观锁操作！ 1234567891011121314#线程一127.0.0.1:6379&gt; watch money#监视 money，获取version，和原来的比较，发现更改了，事务失败。OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; decrby money 20QUEUED127.0.0.1:6379&gt; incrby out 20 #然后在这里，线程二执行set money 10000QUEUED127.0.0.1:6379&gt; exec#发现这里的命令都没有执行，这就是事务为提交，这个是一个乐观锁的实现。(nil)#线程2127.0.0.1:6379&gt; set money 10000OK Jedis 是redis官方推荐的java连接开发工具，使用java操作reids中间件！ 1、直接找maven依赖 2、new 一个Jedis对象，根据Jedis的构造函数，来将redis的主机ip地址和端口号闯进去，之后的命令和上面一样，只是都是jedis.xx的形式调用。 不推荐使用 SpringBoot整合在springboot2.x之后，jedis被替换为lettuce jedis：采用的是直连的，多个线程操作的，是不安全的，如果想要避免不安全的操作，使用jedis pool连接池，使用的是BIO lettuce：采用netty，实例可以在多个线程中进行分享，不存在线程不安全的情况，可以减少线程不安全的情况。可以减少线程数量。NIO 重点： 自定义redisTemplate redis.conf 网络 123bind 127.0.0.1protected-mode yesport 6379 通用 1234567891011121314151617181920daemonize yes #以守护进程的方式运行，默认是no，需要开启为yes# Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably)# warning (only very important / critical messages are logged)loglevel notice# Specify the log file name. Also the empty string can be used to force# Redis to log on the standard output. Note that if you use standard# output for logging but daemonize, logs will be sent to /dev/nulllogfile \"\"#日志的文件名# Set the number of databases. The default database is DB 0, you can select# a different one on a per-connection basis using SELECT &lt;dbid&gt; where# dbid is a number between 0 and 'databases'-1databases 16 #默认的数据库数量 快照 持久化，在规定的时间内，执行了多少次操作，则会持久化到文件.rdb .aof redis是内存数据库，如果没有持久化，断电就会消失 123456789101112131415161718192021222324252627282930313233#900s内，如果至少一个key进行了修改，就会进行持久化操作。save 900 1#300s内，如果至少10个key进行了修改，就会进行持久化操作save 300 10#60s内，如果至少10000个key进行了修改，就会进行持久化操作save 60 10000# By default Redis will stop accepting writes if RDB snapshots are enabled# (at least one save point) and the latest background save failed.# This will make the user aware (in a hard way) that data is not persisting# on disk properly, otherwise chances are that no one will notice and some# disaster will happen.## If the background saving process will start working again Redis will# automatically allow writes again.## However if you have setup your proper monitoring of the Redis server# and persistence, you may want to disable this feature so that Redis will# continue to work as usual even if there are problems with disk,# permissions, and so forth.stop-writes-on-bgsave-error yes#持久化如果出错，是否需要停止工作rdbcompression yes#是否压缩rdb文件# The working directory.## The DB will be written inside this directory, with the filename specified# above using the 'dbfilename' configuration directive.## The Append Only File will also be created inside this directory.## Note that you must specify a directory here, not a file name.dir ./#持久化文件保存的目录 scurity 12345678# IMPORTANT NOTE: starting with Redis 6 \"requirepass\" is just a compatiblity# layer on top of the new ACL system. The option effect will be just setting# the password for the default user. Clients will still authenticate using# AUTH &lt;password&gt; as usually, or more explicitly with AUTH default &lt;password&gt;# if they follow the new protocol: both will work.## requirepass foobaredrequirepass XXX#在这里设置登录密码 限制clients 123456789101112131415161718########################### ACTIVE DEFRAGMENTATION ######################### Once the limit is reached Redis will close all the new connections sending# an error 'max number of clients reached'.## maxclients 10000#设置能连接上redis的最大客户端数量maxmemory-policy noeviction#内存达到上限之后的默认处理策略这个策略有很多种：# volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.对设置了过期时间的keys进行LRU# allkeys-lru -&gt; Evict any key using approximated LRU.对所有的keys进行lru# volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.对设置了过期时间的keys进行lfu# allkeys-lfu -&gt; Evict any key using approximated LFU.对所有的keys进行lfu# volatile-random -&gt; Remove a random key having an expire set.随机的删除设置了过期时间的keys# allkeys-random -&gt; Remove a random key, any key.对所有的keys随机删除# volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)删除即将过期的# noeviction -&gt; Don't evict anything, just return an error on write operations.不做处理，报错 APPEND ONLY aof 12345678appendonly no#默认不开启aof模式，默认使用rdb方式持久化。appendfilename \"appendonly.aof\"#持久化文件的名字#同步策略# appendfsync always#每次修改，都要同步appendfsync everysec#每秒同步一次# appendfsync no","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"Redis学习系列（四）主从复制","slug":"Redis学习系列（四）主从复制","date":"2020-06-20T14:55:56.000Z","updated":"2020-06-20T15:03:15.652Z","comments":true,"path":"2020/06/20/Redis学习系列（四）主从复制/","link":"","permalink":"http://yoursite.com/2020/06/20/Redis%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","excerpt":"","text":"Redis（四）主从复制概念主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器，前者成为主节点（master）后者成为从节点（slave）；数据的复制是单向的，只能由主节点到从节点，Master以写为主，Slave只能读。 默认情况下，每台Redis服务器都是主节点，且一个主节点可以由多个从节点或者没有从节点。但是一个从节点只有一个主节点。 主从复制的作用主要包括 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式 故障恢复：当主节点出现问题，可以由从节点提供服务，实现快速的故障恢复，实际上是一种服务的冗余 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时连接主节点，读redis时应用从节点），分担服务器 负载，尤其在读多写少的情况之下。通过多个从节点分担读负载，可以大大提高redis的并发量 高可用（集群）的基石：除了上述作用之外，主从复制还是哨兵和集群能够实现的基础，因此说是Redis高可用的基石。 一般来说，要将Redis运用在实际的项目中，只使用一台Redis服务器是不可能的，原因： 从结构上，单个Redis服务器会发生单点故障，一台服务器需要处理所有的负载，压力较大 从容量上，单个Redis服务器内存容量限制，一般来说，单台Redis最大使用内存不应该超过20G 环境配置只需要配置从库，不需要配置主库，默认都是主库 12345678910111213127.0.0.1:6379&gt; info replication# 查看当前库的信息# Replicationrole:master#表示主库connected_slaves:0master_replid:b242cbcae6532b3a74762010786610af9cdefeccmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0master_repl_meaningful_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0 复制三个配置文件，修改配置 1、端口号 2、pid名字 3、log文件名字 4、dump.rdb名字 1234567891011121314151617181920212223242526272829303132[root@izbp10mqmhqvedm1cjhdulz bin]# redis-server myconfig/redis-79.conf [root@izbp10mqmhqvedm1cjhdulz bin]# lltotal 45932-rw-r--r-- 1 root root 2380 Jun 20 21:31 6379.log-rw-r--r-- 1 root root 114 Jun 20 21:20 dump.rdbdrwxr-xr-x 2 root root 4096 Jun 20 21:30 myconfig-rwxr-xr-x 1 root root 6397464 Jun 18 12:18 redis-benchmark-rwxr-xr-x 1 root root 11300096 Jun 18 12:18 redis-check-aof-rwxr-xr-x 1 root root 11300096 Jun 18 12:18 redis-check-rdb-rwxr-xr-x 1 root root 6719864 Jun 18 12:18 redis-clilrwxrwxrwx 1 root root 12 Jun 18 12:18 redis-sentinel -&gt; redis-server-rwxr-xr-x 1 root root 11300096 Jun 18 12:18 redis-server[root@izbp10mqmhqvedm1cjhdulz bin]# redis-server myconfig/redis-80.conf [root@izbp10mqmhqvedm1cjhdulz bin]# redis-server myconfig/redis-81.conf [root@izbp10mqmhqvedm1cjhdulz bin]# lltotal 45940-rw-r--r-- 1 root root 2380 Jun 20 21:31 6379.log-rw-r--r-- 1 root root 2380 Jun 20 21:32 6380.log-rw-r--r-- 1 root root 2380 Jun 20 21:32 6381.log-rw-r--r-- 1 root root 114 Jun 20 21:20 dump.rdbdrwxr-xr-x 2 root root 4096 Jun 20 21:30 myconfig-rwxr-xr-x 1 root root 6397464 Jun 18 12:18 redis-benchmark-rwxr-xr-x 1 root root 11300096 Jun 18 12:18 redis-check-aof-rwxr-xr-x 1 root root 11300096 Jun 18 12:18 redis-check-rdb-rwxr-xr-x 1 root root 6719864 Jun 18 12:18 redis-clilrwxrwxrwx 1 root root 12 Jun 18 12:18 redis-sentinel -&gt; redis-server-rwxr-xr-x 1 root root 11300096 Jun 18 12:18 redis-server[root@izbp10mqmhqvedm1cjhdulz bin]# ps -ef|grep redisroot 11466 1 0 21:31 ? 00:00:00 redis-server 127.0.0.1:6379root 11473 1 0 21:32 ? 00:00:00 redis-server 127.0.0.1:6380root 11479 1 0 21:32 ? 00:00:00 redis-server 127.0.0.1:6381root 11488 11125 0 21:32 pts/0 00:00:00 grep --color=auto redis 一主二从目前，所有的都是主节点。只需要配置从机 从机配置 12127.0.0.1:6380&gt; slaveof 127.0.0.1 6379OK 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#从机6380127.0.0.1:6380&gt; info replication# Replicationrole:slavemaster_host:127.0.0.1master_port:6379master_link_status:upmaster_last_io_seconds_ago:1master_sync_in_progress:0slave_repl_offset:0slave_priority:100slave_read_only:1connected_slaves:0master_replid:bb15c7dc4a4e0290cc5c0cafef652d2a8f2f91dcmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0master_repl_meaningful_offset:0second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:0#从机6281127.0.0.1:6381&gt; slaveof 127.0.0.1 6379OK127.0.0.1:6381&gt; info replication# Replicationrole:slavemaster_host:127.0.0.1master_port:6379master_link_status:upmaster_last_io_seconds_ago:1master_sync_in_progress:0slave_repl_offset:168slave_priority:100slave_read_only:1connected_slaves:0master_replid:bb15c7dc4a4e0290cc5c0cafef652d2a8f2f91dcmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:168master_repl_meaningful_offset:154second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:155repl_backlog_histlen:14 123456789101112131415161718#主机中查看信息。127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:2slave0:ip=127.0.0.1,port=6380,state=online,offset=182,lag=1slave1:ip=127.0.0.1,port=6381,state=online,offset=182,lag=1master_replid:bb15c7dc4a4e0290cc5c0cafef652d2a8f2f91dcmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:182master_repl_meaningful_offset:0second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:182127.0.0.1:6379&gt; 永久配置主从 REPLICATION 直接在配置文件中修改该字段。 主从复制的细节 主机可以写，从机不能，只能读 主机中的所有数据和信息，都自动被从机保存。 123456127.0.0.1:6380&gt; keys *1) \"k1\"127.0.0.1:6380&gt; get k1\"v1\"127.0.0.1:6380&gt; set k2 v2(error) READONLY You can't write against a read only replica. 主机断开连接，从机依旧连接到主机，重新连接之后，正常工作。 复制原理Slave启动成功之后连接到master后会发送一个sync命令 Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕之hi偶，master将传送整个数据文件到slave，并完成一次完全同步。 全量复制：slave服务在接收到数据库文件数据后，将其存盘并加载到内存中 增量复制：Master继续将新的所有收集到的修改命令依次传递个slave，完成同步 但是要重新连接master，一次完全同步（全量复制）将被自动执行。 哨兵模式（重点）概述主从切换技术的方法是：当主服务器宕机之后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费时费力，同时会造成一段时间内服务不可用。更多时候，需要考虑使用哨兵模式。 哨兵模式是一种特殊的模式，首先Redis提供哨兵的命令，哨兵是一个独立的进程，作为进程，独立运行。原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例 在这里，烧饼的两个作用 通过发送命令，让Redis服务器返回监控器运行状态信息，包括主从服务器 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发部订阅模式通知其他的从服务器，修改配置文件，切换主机。 然而一个哨兵进程对Redis服务器进行监控，可能会 出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控 假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个想象称为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定的值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover（故障转移）操作。切换成功周，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。 配置哨兵配置文件sentinel.conf12#sentinel monitor 被监控的名称 host port 1sentinel monitor myredis 127.0.0.1 6379 1 后面的数字1，代表主机挂了，slave投票看让谁替换成为主机，票数最多的，成为主机 启动哨兵1redis-sentinel myconfig/setinel.conf 主机宕机 发现主机已经变为6380 如果主机回来了，只能成为slave","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"Redis学习系列（三）持久化","slug":"Redis学习系列（三）持久化","date":"2020-06-20T14:55:42.000Z","updated":"2020-06-20T15:04:59.698Z","comments":true,"path":"2020/06/20/Redis学习系列（三）持久化/","link":"","permalink":"http://yoursite.com/2020/06/20/Redis%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E6%8C%81%E4%B9%85%E5%8C%96/","excerpt":"","text":"Redis(三) 持久化为何要持久化？redis是内存数据库，不过不将内存中的数据保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以redis提供了持久化功能。 RDB 在指定的时间间隔内将内存中的数据集快照写入磁盘中，也就是进行Snapshot快照，恢复时将快照文件直接读到内存。 Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件，整个过程中，主进程不进行任何IO操作，确保极高的性能。如果进行大规模的数据恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加有效，缺点时最后一个持久化的数据可能会丢失。 1、RDB文件的触发 save规则满足的条件下。 会自动触发 执行flushall命令，也会自动触发 退出redis，会产生rdb文件 2、RDB文件的恢复 只要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb恢复其中的数据 查看需要存放的位置。 3、优缺点优点： 适合大规模的数据恢复 如果对数据完整性要求不高，比较适合使用 缺点： 需要一定的时间间隔进行操作，如果redis意外宕机，意味着最后一次修改的数据就没有 了 fork进程的时候，会占用一定的内存空间。 AOF(Append Only File)将我们的所有命令都记录下来，然后再恢复的时候直接全部执行一遍。 以日志的形式记录每个操作，将Redis执行过的所有指令记录下来（读操作不记录），只追加文件但不可以改写文件，redis启动之初将会读该文件重新构建数据，换言之，redis重启是根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 修复 如果aof文件被篡改，导致redis在关机后重启失败，可以使用 1redis-check-aof --fix appendonly.aof 重写 12auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb 如果aof文件大于64mb，fork一个新的进程来重写我们的文件 优缺点 优点： 每一次修改都同步，文件的完整性更加好 每秒同步一次，可能会丢失一秒的数据（同步机制可以设置） 123#appendfsync alwaysappendfsync everysec#appendfsync no 从不同步，效率是最高的 缺点 相对于数据文件来说，aof远大于rdb，修复速度慢 运行效率小于rdb","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"Redis学习系列（一）","slug":"Redis学习系列（一）","date":"2020-06-18T13:29:07.000Z","updated":"2020-06-18T13:30:21.290Z","comments":true,"path":"2020/06/18/Redis学习系列（一）/","link":"","permalink":"http://yoursite.com/2020/06/18/Redis%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Redis学习系列(一)NoSQL概述为什么需要使用NoSQL： 用户的个人信息，社交网络，地理位置等用户自己产生的数据，用户日志等等爆法式增长。这个时候需要使用NoSQL。 因此又有一个问题： 1、到底什么是NoSQL？关系型数据库：表格，行和列。 很多的数据类型用户的个人信息，社交网络，地理位置这些数据的存储不需要一个固定的格式。而NoSQL类型的数据库以其自身的特点能够满足这样的使用要求。 ——百度百科 对于NoSQL并没有一个明确的范围和定义，但是他们都普遍存在下面一些共同特征： 易扩展NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。无形之间，在架构的层面上带来了可扩展的能力。 大数据量，高性能NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。一般MySQL使用Query Cache。NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说性能就要高很多。 灵活的数据模型NoSQL无须事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是——个噩梦。这点在大数据量的Web 2.0时代尤其明显。 高可用NoSQL在不太影响性能的情况，就可以方便地实现高可用的架构。比如Cassandra、HBase模型，通过复制模型也能实现高可用。 2、传统的关系型数据库和NoSQl的区别关系型数据库 结构化组织 SQL 数据和关系都存在单独的表中 数据操作语言，数据定义语言 严格的一致性 基础的事务 。。。 NoSQL 不仅仅是数据 没有固定的查询语言 键值对存储，列存储，文档存储，图形数据库 最终一致性 CAP定理和BASE（异地多活） 高性能,高可用,高可扩展性(扩容) 3、四大分类KV键值对: 新浪:redis 美团:redis+Tair 阿里百度:Redis+memecache 文档型数据库: MongoDB(是一个基于分布式文件存储的数据库,C++编写,主要处理大量的文档,是NoSQL中功能最丰富,最像关系型数据库 列存储数据库 HBase 分布式文件系统 图关系数据库 主要是存储关系的,比如社交网络,图论? Redis入门概述 ——百度百科 Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 ——Redis官方 作用 内存存储、持久化、内存中是断电即失、所以注意持久化 效率高，可以用于高速存储 发布订阅系统 地图信息分析 计时器、技术器（浏览量） 。。。 特性 多样的数据类型 持久化 集群 事务 …… 默认有16个数据库，使用第0个。 Redis是单线程的。是基于内存操作的，CPU不是Redis的性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽。但是6.0以后是多线程的 经典问题之 单线程为何这么快？ redis是将所有的数据都睡存放在内存中，所以使用单线程去操作是效率最高的。（待求证） Redis-key 1234567891011121314151617181920212223242526272829303132127.0.0.1:6379&gt; set shane 123 //添加keyOK127.0.0.1:6379&gt; get shane\"123\"127.0.0.1:6379&gt; expire shane 10 //设置过期时间(integer) 1127.0.0.1:6379&gt; ttl shane //查看当前key的剩余时间(integer) 6127.0.0.1:6379&gt; ttl shane(integer) 2127.0.0.1:6379&gt; ttl shane(integer) 1127.0.0.1:6379&gt; ttl shane(integer) 0127.0.0.1:6379&gt; ttl shane(integer) -2127.0.0.1:6379&gt; get shane(nil)127.0.0.1:6379&gt; set shane 123OK127.0.0.1:6379&gt; get shane\"123\"127.0.0.1:6379&gt; exists shane//判断是否存在这个key(integer) 1127.0.0.1:6379&gt; move shane 1//移动key到指定编号的数据库(integer) 1127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379[1]&gt; keys *1) \"shane\"127.0.0.1:6379[1]&gt; type shane //查看数据类型string 五大数据类型1、String 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114127.0.0.1:6379&gt; get shane#获取key\"123\"127.0.0.1:6379&gt; append shane is #在shane对应的值下添加“is\"返回的是添加成功之后的value长度(integer) 5127.0.0.1:6379&gt; get shane\"123is\"127.0.0.1:6379&gt; append shane1 1 #如果key不存在，就会创建新的key(integer) 1 127.0.0.1:6379&gt; append shane 1234(integer) 10127.0.0.1:6379&gt; strlen shane #string类型的数据的 长度。(integer) 10########################i++操作127.0.0.1:6379&gt; get views\"0\"127.0.0.1:6379&gt; incr views (integer) 1127.0.0.1:6379&gt; incr views (integer) 2127.0.0.1:6379&gt; decr views (integer) 1127.0.0.1:6379&gt; get views \"1\"127.0.0.1:6379&gt; incrby views 10# 设置步长(integer) 11########################字符串范围127.0.0.1:6379&gt; set shane \"hello ,welcome to ZJU \"OK127.0.0.1:6379&gt; get shane\"hello ,welcome to ZJU \"127.0.0.1:6379&gt; getrange shane 0 3 #截取字符串\"hell\"127.0.0.1:6379&gt; getrange shane 0 -1#获取全部字符串，等于get shane\"hello ,welcome to ZJU \"127.0.0.1:6379&gt; #替换127.0.0.1:6379&gt; setrange shane 5 niaho #替换指定位置开是的字符串(integer) 22127.0.0.1:6379&gt; get shane\"helloniahocome to ZJU \"#########################setex(set with expire) #设置过期时间#setnx(set if not exist) #不存在设置，在分布式锁中会经常使用127.0.0.1:6379&gt; setex keys 30 shane #设置keys的值为shane，过期时间为30sOK127.0.0.1:6379&gt; get keys\"shane\"127.0.0.1:6379&gt; ttl keys(integer) 20127.0.0.1:6379&gt; ttl keys(integer) 17127.0.0.1:6379&gt; ttl keys(integer) 13127.0.0.1:6379&gt; ttl keys(integer) -2127.0.0.1:6379&gt; get kyes(nil)127.0.0.1:6379&gt; keys *1) \"shane\"127.0.0.1:6379&gt; setnx key3 \"shane\" #如果创建的key3不存在，创建成功(integer) 1127.0.0.1:6379&gt; keys *1) \"key3\"2) \"shane\"127.0.0.1:6379&gt; setnx key3 \"shane\"#如果创建的key3存在，创建失败(integer) 0##################msetmget 127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3#同时设置多个值OK127.0.0.1:6379&gt; keys *1) \"k2\"2) \"k1\"3) \"k3\"127.0.0.1:6379&gt; mget k1 k2 k3# 同时获取多个值1) \"v1\"2) \"v2\"3) \"v3\"#msetnx是一个原子性操作，要么都成功，要么都失败127.0.0.1:6379&gt; msetnx k1 v1 k4 v4(integer) 0127.0.0.1:6379&gt; get k4(nil)#对象set user:1 &#123;name:zhangsan,age:3&#125; #设置一个user:1对象，值位json字符来保存一个对象！127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2OK127.0.0.1:6379&gt; mget user:1:name user:1:age1) \"zhangsan\"2) \"2\"#redis中可以将key以这种方式来命名：user:&#123;id&#125;:&#123;filed&#125;##############getset #先get后set的组合127.0.0.1:6379&gt; getset key2 \"zhangsan \"#如果不存在key2，会创建一个key2，返回null(nil)127.0.0.1:6379&gt; get key2\"zhangsan \"127.0.0.1:6379&gt; getset key2 \"shane\"#如果存在，会返回修改之前的数据，就是先get后set修改。\"zhangsan \"127.0.0.1:6379&gt; get key2\"shane\" String类型常用的使用场景：value可以是字符串还可以是数字。 可以用来作为 计数器 统计多单位的数量 对象缓存 2、List基本的数据类型，列表 可以使用list实现栈，阻塞队列，队列 所有的命令都是l开头 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#################### 将一个或者多个数据插入列表的头部127.0.0.1:6379&gt; lpush list three(integer) 1127.0.0.1:6379&gt; lpush list one (integer) 2127.0.0.1:6379&gt; lpush list two(integer) 3#获取所有的数据127.0.0.1:6379&gt; lrange list 0 -11) \"two\"2) \"one\"3) \"three\"#获取一个范围的数据，包含两个界127.0.0.1:6379&gt; lrange list 0 11) \"two\"2) \"one\"###########################将一个值或者多个值放到头部。127.0.0.1:6379&gt; lpush shane one(integer) 1127.0.0.1:6379&gt; lpush shane two(integer) 2127.0.0.1:6379&gt; lpush shane three(integer) 3#将一个值或者多个值插入到尾部127.0.0.1:6379&gt; rpush shane right(integer) 4127.0.0.1:6379&gt; lrange shane 0 -11) \"three\"2) \"two\"3) \"one\"4) \"right\"#################移除元素#############127.0.0.1:6379&gt; lpop shane#移除list的第一个元素\"three\"127.0.0.1:6379&gt; lrange shane 0 -11) \"two\"2) \"one\"3) \"right\"127.0.0.1:6379&gt; rpop shane #移除list的最后一个元素\"right\"127.0.0.1:6379&gt; lrange shane 0 -11) \"two\"2) \"one\"#####################127.0.0.1:6379&gt; lindex shane 0#通过下标获取某一个值\"two\"###########################llen127.0.0.1:6379&gt; llen shane #返回列表的长度(integer) 2#############lrem移除指定的值127.0.0.1:6379&gt; lpush shane three(integer) 3127.0.0.1:6379&gt; lpush shane three(integer) 4127.0.0.1:6379&gt; lrange shane 0 -11) \"three\"2) \"three\"3) \"two\"4) \"one\"127.0.0.1:6379&gt; lrem shane 1 three(integer) 1127.0.0.1:6379&gt; lrange shane 0 -11) \"three\"2) \"two\"3) \"one\"127.0.0.1:6379&gt; lpush shane three(integer) 4127.0.0.1:6379&gt; lrem shane 2 three(integer) 2127.0.0.1:6379&gt; lrange shane 0 -11) \"two\"2) \"one\"############## trim 修剪，在redis的list中的截断。 127.0.0.1:6379&gt; rpush mylist \"hello1\"(integer) 1127.0.0.1:6379&gt; rpush mylist \"hello2\"(integer) 2127.0.0.1:6379&gt; rpush mylist \"hello3\"(integer) 3127.0.0.1:6379&gt; rpush mylist \"hello4\"(integer) 4127.0.0.1:6379&gt; ltrim mylist 1 2#通过指定下标截取的长度，这个list已经改变。截断后只剩下最后一个元素OK127.0.0.1:6379&gt; lrange mylist 0 -11) \"hello2\"2) \"hello3\"#################rpoplpush 127.0.0.1:6379&gt; lrange mylist 0 -11) \"hello2\"2) \"hello3\"127.0.0.1:6379&gt; rpoplpush mylist shane#将mylist中操作一个rpop，然后将取得的元素lpush进shane\"hello3\"127.0.0.1:6379&gt; lrange mylist 0 -1#查看源列表1) \"hello2\"127.0.0.1:6379&gt; lrange shane 0 -1#查看目标列表1) \"hello3\"2) \"two\"3) \"one\"#################lset将列表中指定下标的值替换为另外一个值，更新操作127.0.0.1:6379&gt; exists list (integer) 0127.0.0.1:6379&gt; lset list 0 item(error) ERR no such key127.0.0.1:6379&gt; lpush list value(integer) 1127.0.0.1:6379&gt; lset list 0 itemOK127.0.0.1:6379&gt; lrange list 0 01) \"item\"###################linsert127.0.0.1:6379&gt; linsert shane before hello3 other#在指定的元素的前面插入(integer) 4127.0.0.1:6379&gt; lrange shane 0 -11) \"other\"2) \"hello3\"3) \"two\"4) \"one\"127.0.0.1:6379&gt; linsert shane after hello3 new #在指定的元素的后面插入(integer) 5127.0.0.1:6379&gt; lrange shane 0 -11) \"other\"2) \"hello3\"3) \"new\"4) \"two\"5) \"one\" list实际上是一个链表 3、Set set中的值不是重复的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990127.0.0.1:6379&gt; sadd myset \"hello\" #set集合中添加元素(integer) 1127.0.0.1:6379&gt; sadd myset \"shane \"(integer) 1127.0.0.1:6379&gt; smembers myset #查看set的所有值1) \"hello\"2) \"shane \"127.0.0.1:6379&gt; sismember myset hello #判断某一个值是不是在set集合中(integer) 1#获取set集合中的内容元素个数127.0.0.1:6379&gt; scard myset(integer) 2#移除set集合中的某个元素127.0.0.1:6379&gt; srem myset hello(integer) 1127.0.0.1:6379&gt; scard myset(integer) 1#随机获取其中的某个元素127.0.0.1:6379&gt; srandmember mysql(nil)127.0.0.1:6379&gt; srandmember myset\"shane \"127.0.0.1:6379&gt; sadd myset \"hahahah\"(integer) 1127.0.0.1:6379&gt; sadd myset \"shane1\"(integer) 1127.0.0.1:6379&gt; scard myset(integer) 3127.0.0.1:6379&gt; srandmember myset 11) \"shane1\"#删除指定的key，随机删除key127.0.0.1:6379&gt; spop myset\"shane \"127.0.0.1:6379&gt; smembers myset1) \"shane1\"2) \"hahahah\"127.0.0.1:6379&gt; #将一个指定的值移动到另外一个set中127.0.0.1:6379&gt; sadd myset \"shane:Invalid argument(s)127.0.0.1:6379&gt; sadd myset \"shane::Invalid argument(s)127.0.0.1:6379&gt; sadd myset \"shane::\"(integer) 1127.0.0.1:6379&gt; sadd myset \"zhansan\"(integer) 1127.0.0.1:6379&gt; sadd myset \"lisi\"(integer) 1127.0.0.1:6379&gt; sadd myset2 \"hahahah\"(integer) 1127.0.0.1:6379&gt; smove myset myset2 zhansan(integer) 1127.0.0.1:6379&gt; smembers myset1) \"lisi\"2) \"shane::\"127.0.0.1:6379&gt; smembers myset21) \"hahahah\"2) \"zhansan\"#集合操作127.0.0.1:6379&gt; sadd key1 a(integer) 1127.0.0.1:6379&gt; sadd key1 b(integer) 1127.0.0.1:6379&gt; sadd key1 c(integer) 1127.0.0.1:6379&gt; sadd key2 c(integer) 1127.0.0.1:6379&gt; sadd key2 d(integer) 1127.0.0.1:6379&gt; sadd key2 e (integer) 1127.0.0.1:6379&gt; sdiff key1 key2#key1中取key2中没有的 1) \"a\"2) \"b\"127.0.0.1:6379&gt; sdiff key2 key1#key2中取key1中没有的1) \"e\"2) \"d\"127.0.0.1:6379&gt; sinter key1 key2 #key1和key2的交集1) \"c\"127.0.0.1:6379&gt; sunion key1 key2 #key1和key2的并集1) \"a\"2) \"c\"3) \"b\"4) \"d\"5) \"e\" 4、Hashkey-map（k-v） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; hset myhash field1 shane#set一个具体的key-value(integer) 1127.0.0.1:6379&gt; hget myhash field1\"shane\"127.0.0.1:6379&gt; hmset myhash field hello field2 world#set多个key-valueOK127.0.0.1:6379&gt; hmget myhash field field2#获取多个字段值1) \"hello\"2) \"world\"127.0.0.1:6379&gt; hgetall myhash#获取所有的值1) \"field1\"2) \"shane\"3) \"field\"4) \"hello\"5) \"field2\"6) \"world\"#删除指定的key字段，对应的value一起删除127.0.0.1:6379&gt; hdel myhash field1(integer) 1127.0.0.1:6379&gt; hgetall myhash1) \"field\"2) \"hello\"3) \"field2\"4) \"world\"#hlen获取hash表的长度127.0.0.1:6379&gt; hlen myhash(integer) 2#hexists 判断是否存在对应的key127.0.0.1:6379&gt; hexists myhash field2(integer) 1127.0.0.1:6379&gt; hexists myhash field(integer) 1127.0.0.1:6379&gt; hexists myhash fiel(integer) 0#获得所有的value127.0.0.1:6379&gt; hvals myhash1) \"hello\"2) \"world\"#只获得所有field值127.0.0.1:6379&gt; hkeys myhash1) \"field\"2) \"field2\"#incr127.0.0.1:6379&gt; hset myhash fields3 5(integer) 1127.0.0.1:6379&gt; hincrby myhash fields3 1#指定增量1(integer) 6127.0.0.1:6379&gt; hsetnx myhash field4 hello#如果不存在可以创建(integer) 1127.0.0.1:6379&gt; hsetnx myhash field4 hello#如果存在不可以设置(integer) 0 hash变更的数据user name age,尤其是用户信息之类的，经常变动的 信息！hash更加适合对象的存储，String更加适合字符串的存储 5、Zset（有序集合） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960127.0.0.1:6379&gt; zadd myZset 1 one(integer) 1127.0.0.1:6379&gt; zadd myzset 2 two 3 three(integer) 2127.0.0.1:6379&gt; zrange myzset 0 -11) \"two\"2) \"three\"127.0.0.1:6379&gt; zadd myZset 2 two 3 three (integer) 2127.0.0.1:6379&gt; zrange myZset 0 -11) \"one\"2) \"two\"3) \"three\"#既然是有序的，就可以排序127.0.0.1:6379&gt; zadd salary 2500 zhangsan(integer) 1127.0.0.1:6379&gt; zadd salary 3000 lisi(integer) 1127.0.0.1:6379&gt; zadd salary 300 wangwu(integer) 1127.0.0.1:6379&gt; zrangebyscore salary -inf +inf1) \"wangwu\"2) \"zhangsan\"3) \"lisi\"127.0.0.1:6379&gt; zrangebyscore salary -inf inf withscores1) \"wangwu\"2) \"300\"3) \"zhangsan\"4) \"2500\"5) \"lisi\"6) \"3000\"127.0.0.1:6379&gt; zrangebyscore salary -inf 2600 withscores1) \"wangwu\"2) \"300\"3) \"zhangsan\"4) \"2500\"#移除127.0.0.1:6379&gt; zrange salary 0 -1#获取所有元素，默认从小到大1) \"wangwu\"2) \"zhangsan\"3) \"lisi\"127.0.0.1:6379&gt; zrevrange salary 0 -1#默认从大到小进行排序1) \"lisi\"2) \"wangwu\"127.0.0.1:6379&gt; zrem salary zhangsan#移除指定的元素(integer) 1127.0.0.1:6379&gt; zrange salary 0 -11) \"wangwu\"2) \"lisi\"127.0.0.1:6379&gt; zcard salary#获取有序集合中的个数(integer) 2#按照区间获取成员数量127.0.0.1:6379&gt; zcount myset 1 3(integer) 3127.0.0.1:6379&gt; zcount myset 1 2(integer) 2","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"Linux安装Redis","slug":"Linux安装Redis","date":"2020-06-18T04:34:57.000Z","updated":"2020-06-18T04:37:49.437Z","comments":true,"path":"2020/06/18/Linux安装Redis/","link":"","permalink":"http://yoursite.com/2020/06/18/Linux%E5%AE%89%E8%A3%85Redis/","excerpt":"","text":"服务器安装Redis 这次吸取教训，将所有的安装步骤都记录下来，不然可太伤了 ！！！重要 记得redis不能公开ip访问，否则容易被攻击，亲身体验 下载Redis官网下载 本次版本：redis-6.0.3.tar.gz 解压将安装包放到/opt下并解压 1tar -zxvf redis-6.0.3.tar.gz 编译安装安装编译环境 1yum install gcc-c++ 1make 等待编译完成 报错 是因为gcc版本过低，默认是4.8.5，而6以上的都需要新的 gcc支持 1234567&#x2F;&#x2F;升级gcc到9以上yum -y install centos-release-sclyum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils&#x2F;&#x2F;临时将此时的gcc版本改为9scl enable devtoolset-9 bash 12makemake install redis默认安装路径 usr/local/bin 配置新建一个文件夹，在usr/local/bin下，myconfig 1mkdir myconfig 将配置文件拷贝过来 1cp &#x2F;opt&#x2F;redis-6.0.3&#x2F;redis.conf myconfig&#x2F; 修改配置文件 1vim redis.conf 开启服务1redis-server myconfig&#x2F;redis.conf 12&#x2F;&#x2F;使用redis-cli连接，使用redisredis-cli -p 6379 12&#x2F;&#x2F;查看redis进程ps -ef|grep redis 123&#x2F;&#x2F;关闭在redis-cli下键入shutdown","categories":[],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}]},{"title":"Linux安装JDK1.8","slug":"Linux安装JDK1-8","date":"2020-06-18T03:13:19.000Z","updated":"2020-06-18T03:18:34.223Z","comments":true,"path":"2020/06/18/Linux安装JDK1-8/","link":"","permalink":"http://yoursite.com/2020/06/18/Linux%E5%AE%89%E8%A3%85JDK1-8/","excerpt":"","text":"Linux安装JDK1.81、下载JDKOracle 官网下载JDK版本，准备安装 本次安装：jdk-8u251-linux-x64.tar.gz 2、创建目录在/usr/目录下创建java目录 12mkdir &#x2F;usr&#x2F;javacd &#x2F;usr&#x2F;java 把下载的文件放在/usr/java/目录下 3、解压JDK1tar -zxvf jdk-8u151-linux-x64.tar.gz 4、设置环境变量1vim &#x2F;etc&#x2F;profile 在最后添加 123456set java environmentJAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_251 JRE_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_251&#x2F;jre CLASS_PATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;libPATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;binexport JAVA_HOME JRE_HOME CLASS_PATH PATH 注意JAVA_HOME、JRE_HOME版本号对应，路径的正确。 让修改生效 1source &#x2F;etc&#x2F;profile 5、验证1java -version 显示 1234[root@izbp10mqmhqvedm1cjhdulz jdk1.8.0_251]# java -versionjava version &quot;1.8.0_251&quot;Java(TM) SE Runtime Environment (build 1.8.0_251-b08)Java HotSpot(TM) 64-Bit Server VM (build 25.251-b08, mixed mode)","categories":[],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}]},{"title":"SpringBoot:diy启动类","slug":"SpringBoot-diy启动类","date":"2020-05-12T05:29:27.000Z","updated":"2020-05-12T05:34:00.402Z","comments":true,"path":"2020/05/12/SpringBoot-diy启动类/","link":"","permalink":"http://yoursite.com/2020/05/12/SpringBoot-diy%E5%90%AF%E5%8A%A8%E7%B1%BB/","excerpt":"","text":"SpringBoot: diy启动类SpringBoot启动类分析在springboot的依赖中，我们通过添加各种启动类，可以省去很多配置的麻烦。因此要想自定义一个启动类，了解其实现也是很重要的一环。 在此，通过堆webAutoconfiguration的分析来认识一个启动类的结构。 主要包含两个项目，一个是spring-boot-starter-web,他是一个空的jar包，其依赖了autoconfiguration这个包，也就是spring-boot-starter-autoconfiguration，因此能够直接使用其中的WebMvcAutoConfiguration自动配置类。 问题来了，如果这个spring-boot-starter-autoconfiguration中的所有配置类都注册岂不是太浪费资源。解决的办法就是增加@Conditional 注解，比如对于WebMvcAutoConfiguration: 拓展： 只有在其中的类存在的时候才会生效，因此这个条件很重要。 1@ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 这个条件和@EnableWebMvc 矛盾，只要在一个类，比如自定义一个WebMVC配置类，上增加@EnableWebMvc注解，就会完全接管WebMvc的控制，所以官方文档建议在拓展WebMvc的配置的时候，不能增加该注解。 结论： 其实写自己启动器也就是大致5个步骤 1：编写自己具体的业务，根据自己的需求。 2：xxxProperties配置文件的编写 3：xxxAutoConfigure的编写 4：将我们的启动类放到springboot项目中的resouces/META-INT下面的spring.factories（这个目录以及文件需要自己手动建） 5：将自己编写的自动配置安装到Maven仓库即可。 6：测试。 说明 官方命名： 前缀：spring-boot-starter-xxx 比如：spring-boot-starter-web…. 自定义命名： xxx-spring-boot-starter 比如：mybatis-spring-boot-starter DIY一个启动类1、首先新建一个空项目（Empty project）spring-boot-starter-diy 然后添加一个普通Maven模块：shane-spring-boot-starter 添加一个springboot模块: shane-spring-boot-starter-autoconfigure，删掉pom中的除spring-boot-starter之外的所有依赖。并且删除不必要的文件夹 项目结构如图： 2、在spring-boot-starter-diy的pom文件中，添加依赖 123456789&lt;!--启动器--&gt; &lt;dependencies&gt;&lt;!-- 引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.shane&lt;/groupId&gt; &lt;artifactId&gt;shane-spring-boot-starter-autoconfigure&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、接下来在包com.shane下新建HelloService, HelloProperties, HelloServiceAutoConfiguration HelloService: 服务目标是，针对输入的字符串，自动增加前后缀 1234567891011121314151617package com.shane;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHello(String name)&#123; return helloProperties.getPrefix() + name + helloProperties.getSuffix(); &#125;&#125; HelloProperties 12345678910111213141516171819202122232425package com.shane;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = \"shane.hello\")public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; HelloServiceAutoConfiguration 123456789101112131415161718192021package com.shane;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication//web应用生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service=new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 4、在resource\\META-INF下新建spring.factories 123# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\com.shane.HelloServiceAutoConfiguration 5、添加到Maven工程中 测试新建一个springboot工程，并添加web依赖 添加自定义启动类的依赖 123456&lt;!--自定义的启动类--&gt;&lt;dependency&gt; &lt;groupId&gt;com.shane&lt;/groupId&gt; &lt;artifactId&gt;shane-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 导入之后 成功导入jar包 编写Controller类验证 1234567891011121314151617package com.shane.controller;import com.shane.HelloService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @Autowired HelloService helloService; @RequestMapping(\"/hello\") public String hello()&#123; return helloService.sayHello(\"sxj\"); &#125;&#125; 在配置文件appliacation.properties中添加 12shane.hello.prefix&#x3D;&quot;hi,&quot;shane.hello.suffix&#x3D;&quot;,welcome!&quot; 运行：","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SSM整合学习笔记","slug":"SSM整合学习笔记","date":"2020-05-10T13:13:13.000Z","updated":"2020-05-10T13:32:51.749Z","comments":true,"path":"2020/05/10/SSM整合学习笔记/","link":"","permalink":"http://yoursite.com/2020/05/10/SSM%E6%95%B4%E5%90%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"SSM整合（模板）首先声明一下环境 12345JDK：1.8Tomcat：8.5.54Idea：2019MySQL：5.7.29Maven：3.6.3 创建一个数据库 123456789101112131415161718CREATE DATABASE `ssmbuild`;USE `ssmbuild`;DROP TABLE IF EXISTS `books`;CREATE TABLE `books` (`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id',`bookName` VARCHAR(100) NOT NULL COMMENT '书名',`bookCounts` INT(11) NOT NULL COMMENT '数量',`detail` VARCHAR(200) NOT NULL COMMENT '描述',KEY `bookID` (`bookID`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES (1,'Java',1,'从入门到放弃'),(2,'MySQL',10,'从删库到跑路'),(3,'Linux',5,'从进门到进牢'); 新建工程SSM_Template，导入Maven依赖。包括mybatis，mybatis-spring，springmvc，junit，servlet，jsp，数据库MySQL驱动，数据库连接池（这里使用c3p0） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 同时配置资源过滤设置 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; （由于新建工程时，没有选择任何模板，因此不要忘记在ＷEb-INF中引入lib目录，并导入所有的jar包，（一定不能漏掉） 创建好所有的包目录 com.shane.dao com.shane.service com.shane.pojo com.shane.controller 1. Mybatis层新建dao接口和对应的mapper配置文件 新建UserDao接口 123456789101112public interface BooksDao &#123; //增加一本书 int addBook(Books books); //删除一本书 int deleteBookById(@Param(\"bookId\") int id); //更新一本书 int updateBook(Books books); //查询一本书 Books queryByBookId(int id); //查询所有书 List&lt;Books&gt; queryAllBook();&#125; 同时创建对应的Mapper配置文件，BooksDaoMapper.xml 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.shane.dao.BooksDao\"&gt; &lt;insert id=\"addBook\" parameterType=\"Books\"&gt; insert into ssmbuild.books(bookName, bookCounts, detail) values (#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;detail&#125;); &lt;/insert&gt; &lt;delete id=\"deleteBookById\" parameterType=\"int\"&gt; delete from ssmbuild.books where bookID=#&#123;bookId&#125; &lt;/delete&gt; &lt;update id=\"updateBook\" parameterType=\"Books\"&gt; update ssmbuild.books set bookName=#&#123;bookName&#125;,bookCounts=#&#123;bookCounts&#125;,detail=#&#123;detail&#125; where bookID=#&#123;bookId&#125;; &lt;/update&gt; &lt;select id=\"queryBookById\" resultType=\"Books\"&gt; select * from ssmbuild.books where bookID=#&#123;bookId&#125; &lt;/select&gt; &lt;select id=\"queryAllBook\" resultType=\"Books\"&gt; select * from ssmbuild.books &lt;/select&gt;&lt;/mapper&gt; 配置mybatis，创建Mybatis-config.xml，其中配置数据源的部分交给spring完成。 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=\"com.shane.pojo\"/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource=\"com/shane/dao/BooksDaoMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2. Spring层 整合mybatis，新建配置文件spirng-dao.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置整合mybatis --&gt; &lt;!-- 1.关联数据库文件 --&gt; &lt;context:property-placeholder location=\"classpath:database.properties\"/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面） --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=\"maxPoolSize\" value=\"30\"/&gt; &lt;property name=\"minPoolSize\" value=\"3\"/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=\"autoCommitOnClose\" value=\"false\"/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=\"checkoutTimeout\" value=\"10000\"/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=\"acquireRetryAttempts\" value=\"2\"/&gt; &lt;/bean&gt;&lt;!-- 3.配置sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;&lt;!-- 注入数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;!-- 绑定mybatis--&gt; &lt;property name=\"configLocation\" value=\"classpath:Mybatis-config.xml\"/&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt; &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=\"basePackage\" value=\"com.shane.dao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 整合service层，新建spring-service.xml 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;!--1.扫描service相关的bean--&gt; &lt;context:component-scan base-package=\"com.shane.service\"/&gt; &lt;!--BookServiceImpl注入到ioc容器中--&gt; &lt;bean id=\"bookServiceImpl\" class=\"com.shane.service.BooksServiceImpl\"&gt; &lt;property name=\"bookMapper\" ref=\"booksDao\"/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 3. SpringMVC层添加web支持之后，配置web.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--注册dispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--乱码问题--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session过期时间--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; 配置mvc，创建spring-mvc.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 2.静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--配置视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\" /&gt; &lt;!--注意在这边的prefix中，WEB—INF前面一定要加“/”，否则404欢迎你--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package=\"com.shane.controller\" /&gt;&lt;/beans&gt; 整合spring的配置文件，新建applicationContext.xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;import resource=\"spring-service.xml\"/&gt; &lt;import resource=\"spring-dao.xml\"/&gt; &lt;import resource=\"spring-mvc.xml\"/&gt;&lt;/beans&gt; 到处为止，所有的配置都已经结束。 4. 新建controller测试web1234567891011121314@Controller@RequestMapping(\"/book\")public class SSMController &#123; @Autowired @Qualifier(\"bookServiceImpl\") private BooksService booksService; @RequestMapping(\"/allBook\") public String findAll(Model model)&#123; List&lt;Books&gt; books=booksService.queryAllBook(); model.addAttribute(\"booklist\",books); return \"hello\"; &#125;&#125; 视图的建立 index.jsp 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/book/allBook\"&gt;点击进入列表页&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; hello.jsp 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hi,ssm&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 运行即可。 测试数据库操作是否正确 新建测试类MyTest.java 1234567891011public class MyTest &#123; @Test public void test()&#123; ApplicationContext context=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BooksService bookServiveImpl=(BooksService) context.getBean(\"bookServiceImpl\"); for(Books books:bookServiveImpl.queryAllBook())&#123; System.out.println(books); &#125; &#125;&#125; 运行结果为 成功。","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringMVC之入门","slug":"SpringMVC之入门","date":"2020-05-09T05:15:39.000Z","updated":"2020-05-09T05:23:59.494Z","comments":true,"path":"2020/05/09/SpringMVC之入门/","link":"","permalink":"http://yoursite.com/2020/05/09/SpringMVC%E4%B9%8B%E5%85%A5%E9%97%A8/","excerpt":"","text":"SpringMVC什么是MVC MVC是一个简写：Model、View、Controller。是一种软件设计的规范，一种架构模式 将业务逻辑、数据、显示分离出来 降低了视图和业务逻辑之间的双向耦合 Model：数据模型，提供要展示的数据，包含数据和行为，可以认为是JavaBean组件。一般现在都分离开来：数据Dao和服务层（行为Service）。 View：负责模型的展示，就是我们所见到的用户界面。 Controller：接收用户请求，委托给模型处理，处理完毕后返回给视图，控制器做了调度的工作。在之前，其实都是指Servlet。 实体类的细分：pojo：可以分为userVO, dto Model1时代主要分为两层，视图层和模型层。 Model2分为MVC三层。 步骤: 用户发送请求 Servlet接收请求数据,并调用对应的业务逻辑方法 业务处理完毕, 返回更新后的数据给servlet servlet转向到JSP,由JSP来渲染页面 响应给前端更新后的页面 Model: 业务逻辑, 保存数据的状态 Controller: 接收表单数据, 调用业务逻辑, 转向指定的页面 View: 显示页面. 什么是 SpringMVC spring的web框架围绕dispatcherServlet设计 使用xml配置文件入门springmvc通过这个小项目,来理解springmvc的工作原理 新建新的子项目springmvc-02-hello,导入依赖 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;springMVCkuang&lt;/artifactId&gt; &lt;groupId&gt;com.kuang&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;springmvc-02-hello&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置web.xml,注册dispatcherServlet 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3、编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 说明，这里的名称要求是按照官方来的 12&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; 4、添加 处理映射器 1&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; 5、添加 处理器适配器 1&lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; 6、添加 视图解析器 1234567&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 7、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； 1234567891011121314151617181920package com.kuang.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //ModelAndView 模型和视图 ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model mv.addObject(\"msg\",\"HelloSpringMVC!\"); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(\"hello\"); //: /WEB-INF/jsp/hello.jsp return mv; &#125;&#125; 8、将自己的类交给SpringIOC容器，注册bean 1&lt;!--Handler--&gt;&lt;bean id=\"/hello\" class=\"com.kuang.controller.HelloController\"/&gt; 9、写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 10、配置Tomcat 启动测试！ 注意:在tomcat配置中,需要将此设置 为”/“ 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！ 重启Tomcat 即可解决！ 执行原理 注解版 新建module,命名为springmvc-servlet-anno 在web.xml中注册dispatcherservlet 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet-anno.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 然后在resource目录下配置springmvc的配置文件,命名为springmvc-servlet-anno. 同时配置处理器映射器处理器适配器,以及视图解析器. 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt; &lt;context:component-scan base-package=\"com.kuangsheng.controller\"&gt;&lt;/context:component-scan&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 新建com.kuangsheng.controller.HelloController 1234567891011121314package com.kuangsheng.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123; @RequestMapping(\"/hello\")//访问路径为localhost8080/hello public String sayHello(Model model)&#123; model.addAttribute(\"msg\",\"helloMvc\"); return \"hello\";//直接交给视图解析器,转到/WEB-INF/jsp/hello.jsp &#125;&#125; 注意404错误,同上的解决方案.考虑lib目录","categories":[],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]}],"categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"},{"name":"软件安装","slug":"软件安装","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]}