{"title":"Redis学习系列（三）持久化","slug":"Redis学习系列（三）持久化","date":"2020-06-20T14:55:42.000Z","updated":"2020-06-20T15:04:59.698Z","comments":true,"path":"api/articles/Redis学习系列（三）持久化.json","excerpt":null,"covers":["image-20200620174911018.png","image-20200620204549761.png"],"content":"<h1 id=\"Redis-三-持久化\"><a href=\"#Redis-三-持久化\" class=\"headerlink\" title=\"Redis(三) 持久化\"></a>Redis(三) 持久化</h1><p><strong>为何要持久化？</strong>redis是内存数据库，不过不将内存中的数据保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以redis提供了持久化功能。</p>\n<h2 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h2><p><img src=\"image-20200620174911018.png\" alt=\"alt\"></p>\n<p>在指定的时间间隔内将内存中的数据集快照写入磁盘中，也就是进行Snapshot快照，恢复时将快照文件直接读到内存。</p>\n<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件，整个过程中，主进程不进行任何IO操作，确保极高的性能。如果进行大规模的数据恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加有效，缺点时最后一个持久化的数据可能会丢失。</p>\n<h3 id=\"1、RDB文件的触发\"><a href=\"#1、RDB文件的触发\" class=\"headerlink\" title=\"1、RDB文件的触发\"></a>1、RDB文件的触发</h3><ul>\n<li>save规则满足的条件下。 会自动触发</li>\n<li>执行flushall命令，也会自动触发</li>\n<li>退出redis，会产生rdb文件</li>\n</ul>\n<h3 id=\"2、RDB文件的恢复\"><a href=\"#2、RDB文件的恢复\" class=\"headerlink\" title=\"2、RDB文件的恢复\"></a>2、RDB文件的恢复</h3><ul>\n<li>只要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb恢复其中的数据</li>\n<li>查看需要存放的位置。</li>\n</ul>\n<h3 id=\"3、优缺点\"><a href=\"#3、优缺点\" class=\"headerlink\" title=\"3、优缺点\"></a>3、优缺点</h3><p>优点：</p>\n<ul>\n<li>适合大规模的数据恢复</li>\n<li>如果对数据完整性要求不高，比较适合使用</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>需要一定的时间间隔进行操作，如果redis意外宕机，意味着最后一次修改的数据就没有 了</li>\n<li>fork进程的时候，会占用一定的内存空间。</li>\n</ul>\n<h2 id=\"AOF-Append-Only-File\"><a href=\"#AOF-Append-Only-File\" class=\"headerlink\" title=\"AOF(Append Only File)\"></a>AOF(Append Only File)</h2><p>将我们的所有命令都记录下来，然后再恢复的时候直接全部执行一遍。</p>\n<p><img src=\"image-20200620204549761.png\" alt=\"alt\"></p>\n<p>以日志的形式记录每个操作，将Redis执行过的所有指令记录下来（读操作不记录），只追加文件但不可以改写文件，redis启动之初将会读该文件重新构建数据，换言之，redis重启是根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>\n<blockquote>\n<p>修复</p>\n</blockquote>\n<p>如果aof文件被篡改，导致redis在关机后重启失败，可以使用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>重写</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto-aof-rewrite-percentage 100</span><br><span class=\"line\">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>\n\n<p>如果aof文件大于64mb，fork一个新的进程来重写我们的文件</p>\n<blockquote>\n<p>优缺点</p>\n</blockquote>\n<p>优点：</p>\n<ul>\n<li><p>每一次修改都同步，文件的完整性更加好</p>\n</li>\n<li><p>每秒同步一次，可能会丢失一秒的数据（同步机制可以设置）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#appendfsync always</span></span><br><span class=\"line\">appendfsync everysec</span><br><span class=\"line\"><span class=\"comment\">#appendfsync no</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从不同步，效率是最高的</p>\n</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>相对于数据文件来说，aof远大于rdb，修复速度慢</li>\n<li>运行效率小于rdb</li>\n</ul>\n","more":"<h1 id=\"Redis-三-持久化\"><a href=\"#Redis-三-持久化\" class=\"headerlink\" title=\"Redis(三) 持久化\"></a>Redis(三) 持久化</h1><p><strong>为何要持久化？</strong>redis是内存数据库，不过不将内存中的数据保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以redis提供了持久化功能。</p>\n<h2 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h2><p><img src=\"image-20200620174911018.png\" alt=\"alt\"></p>\n<p>在指定的时间间隔内将内存中的数据集快照写入磁盘中，也就是进行Snapshot快照，恢复时将快照文件直接读到内存。</p>\n<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件，整个过程中，主进程不进行任何IO操作，确保极高的性能。如果进行大规模的数据恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加有效，缺点时最后一个持久化的数据可能会丢失。</p>\n<h3 id=\"1、RDB文件的触发\"><a href=\"#1、RDB文件的触发\" class=\"headerlink\" title=\"1、RDB文件的触发\"></a>1、RDB文件的触发</h3><ul>\n<li>save规则满足的条件下。 会自动触发</li>\n<li>执行flushall命令，也会自动触发</li>\n<li>退出redis，会产生rdb文件</li>\n</ul>\n<h3 id=\"2、RDB文件的恢复\"><a href=\"#2、RDB文件的恢复\" class=\"headerlink\" title=\"2、RDB文件的恢复\"></a>2、RDB文件的恢复</h3><ul>\n<li>只要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb恢复其中的数据</li>\n<li>查看需要存放的位置。</li>\n</ul>\n<h3 id=\"3、优缺点\"><a href=\"#3、优缺点\" class=\"headerlink\" title=\"3、优缺点\"></a>3、优缺点</h3><p>优点：</p>\n<ul>\n<li>适合大规模的数据恢复</li>\n<li>如果对数据完整性要求不高，比较适合使用</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>需要一定的时间间隔进行操作，如果redis意外宕机，意味着最后一次修改的数据就没有 了</li>\n<li>fork进程的时候，会占用一定的内存空间。</li>\n</ul>\n<h2 id=\"AOF-Append-Only-File\"><a href=\"#AOF-Append-Only-File\" class=\"headerlink\" title=\"AOF(Append Only File)\"></a>AOF(Append Only File)</h2><p>将我们的所有命令都记录下来，然后再恢复的时候直接全部执行一遍。</p>\n<p><img src=\"image-20200620204549761.png\" alt=\"alt\"></p>\n<p>以日志的形式记录每个操作，将Redis执行过的所有指令记录下来（读操作不记录），只追加文件但不可以改写文件，redis启动之初将会读该文件重新构建数据，换言之，redis重启是根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>\n<blockquote>\n<p>修复</p>\n</blockquote>\n<p>如果aof文件被篡改，导致redis在关机后重启失败，可以使用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>重写</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto-aof-rewrite-percentage 100</span><br><span class=\"line\">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>\n\n<p>如果aof文件大于64mb，fork一个新的进程来重写我们的文件</p>\n<blockquote>\n<p>优缺点</p>\n</blockquote>\n<p>优点：</p>\n<ul>\n<li><p>每一次修改都同步，文件的完整性更加好</p>\n</li>\n<li><p>每秒同步一次，可能会丢失一秒的数据（同步机制可以设置）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#appendfsync always</span></span><br><span class=\"line\">appendfsync everysec</span><br><span class=\"line\"><span class=\"comment\">#appendfsync no</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从不同步，效率是最高的</p>\n</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>相对于数据文件来说，aof远大于rdb，修复速度慢</li>\n<li>运行效率小于rdb</li>\n</ul>\n","categories":[],"tags":[{"name":"Redis","path":"api/tags/Redis.json"}]}